<<<<<<< HEAD
/**
 * @param {object} exports
 * @param {Set<string>} keys
 */
function loop(exports, keys) {
	if (typeof exports === 'string') {
		return exports;
	}

	if (exports) {
		let idx, tmp;
		if (Array.isArray(exports)) {
			for (idx=0; idx < exports.length; idx++) {
				if (tmp = loop(exports[idx], keys)) return tmp;
			}
		} else {
			for (idx in exports) {
				if (keys.has(idx)) {
					return loop(exports[idx], keys);
				}
			}
		}
	}
}

/**
 * @param {string} name The package name
 * @param {string} entry The target entry, eg "."
 * @param {number} [condition] Unmatched condition?
 */
function bail(name, entry, condition) {
	throw new Error(
		condition
		? `No known conditions for "${entry}" entry in "${name}" package`
		: `Missing "${entry}" export in "${name}" package`
	);
}

/**
 * @param {string} name the package name
 * @param {string} entry the target path/import
 */
function toName(name, entry) {
	return entry === name ? '.'
		: entry[0] === '.' ? entry
		: entry.replace(new RegExp('^' + name + '\/'), './');
}

/**
 * @param {object} pkg package.json contents
 * @param {string} [entry] entry name or import path
 * @param {object} [options]
 * @param {boolean} [options.browser]
 * @param {boolean} [options.require]
 * @param {string[]} [options.conditions]
 * @param {boolean} [options.unsafe]
 */
export function resolve(pkg, entry='.', options={}) {
	let { name, exports } = pkg;

	if (exports) {
		let { browser, require, unsafe, conditions=[] } = options;

		let target = toName(name, entry);
		if (target !== '.' && !target.startsWith('./')) {
			target = './' + target; // ".ini" => "./.ini"
		}

		if (typeof exports === 'string') {
			return target === '.' ? exports : bail(name, target);
		}

		let allows = new Set(['default', ...conditions]);
		unsafe || allows.add(require ? 'require' : 'import');
		unsafe || allows.add(browser ? 'browser' : 'node');

		let key, m, k, kv, tmp, isSingle=false;

		for (key in exports) {
			isSingle = key[0] !== '.';
			break;
		}

		if (isSingle) {
			return target === '.'
				? loop(exports, allows) || bail(name, target, 1)
				: bail(name, target);
		}

		if (tmp = exports[target]) {
			return loop(tmp, allows) || bail(name, target, 1);
		}

		if (target !== '.') {
			for (key in exports) {
				if (k && key.length < k.length) {
					// do not allow "./" to match if already matched "./foo*" key
				} else if (key[key.length - 1] === '/' && target.startsWith(key)) {
					kv = target.substring(key.length);
					k = key;
				} else {
					tmp = key.indexOf('*', 2);
					if (!!~tmp) {
						m = RegExp(
							'^\.\/' + key.substring(2, tmp) + '(.*)' + key.substring(1+tmp)
						).exec(target);

						if (m && m[1]) {
							kv = m[1];
							k = key;
						}
					}
				}
			}

			if (k && kv) {
				// must have value
				tmp = loop(exports[k], allows);
				if (!tmp) return bail(name, target);

				return tmp.includes('*')
					? tmp.replace(/[*]/g, kv)
					: tmp + kv;
			}
		}

		return bail(name, target);
	}
}

/**
 * @param {object} pkg
 * @param {object} [options]
 * @param {string|boolean} [options.browser]
 * @param {string[]} [options.fields]
 */
export function legacy(pkg, options={}) {
	let i=0, value,
		browser = options.browser,
		fields = options.fields || ['module', 'main'];

	if (browser && !fields.includes('browser')) {
		fields.unshift('browser');
	}

	for (; i < fields.length; i++) {
		if (value = pkg[fields[i]]) {
			if (typeof value == 'string') {
				//
			} else if (typeof value == 'object' && fields[i] == 'browser') {
				if (typeof browser == 'string') {
					value = value[browser=toName(pkg.name, browser)];
					if (value == null) return browser;
				}
			} else {
				continue;
			}

			return typeof value == 'string'
				? ('./' + value.replace(/^\.?\//, ''))
				: value;
		}
	}
}
=======
function e(e,n,r){throw new Error(r?`No known conditions for "${n}" specifier in "${e}" package`:`Missing "${n}" specifier in "${e}" package`)}function n(n,i,o,f){let s,u,l=r(n,o),c=function(e){let n=new Set(["default",...e.conditions||[]]);return e.unsafe||n.add(e.require?"require":"import"),e.unsafe||n.add(e.browser?"browser":"node"),n}(f||{}),a=i[l];if(void 0===a){let e,n,r,t;for(t in i)n&&t.length<n.length||("/"===t[t.length-1]&&l.startsWith(t)?(u=l.substring(t.length),n=t):t.length>1&&(r=t.indexOf("*",1),~r&&(e=RegExp("^"+t.substring(0,r)+"(.*)"+t.substring(1+r)+"$").exec(l),e&&e[1]&&(u=e[1],n=t))));a=i[n]}return a||e(n,l),s=t(a,c),s||e(n,l,1),u&&function(e,n){let r,t=0,i=e.length,o=/[*]/g,f=/[/]$/;for(;t<i;t++)e[t]=o.test(r=e[t])?r.replace(o,n):f.test(r)?r+n:r}(s,u),s}function r(e,n,r){if(e===n||"."===n)return".";let t=e+"/",i=t.length,o=n.slice(0,i)===t,f=o?n.slice(i):n;return"#"===f[0]?f:o||!r?"./"===f.slice(0,2)?f:"./"+f:f}function t(e,n,r){if(e){if("string"==typeof e)return r&&r.add(e),[e];let i,o;if(Array.isArray(e)){for(o=r||new Set,i=0;i<e.length;i++)t(e[i],n,o);if(!r&&o.size)return[...o]}else for(i in e)if(n.has(i))return t(e[i],n,r)}}function i(e,n={}){let t,i=0,o=n.browser,f=n.fields||["module","main"],s="string"==typeof o;for(o&&!f.includes("browser")&&(f.unshift("browser"),s&&(o=r(e.name,o,!0)));i<f.length;i++)if(t=e[f[i]]){if("string"==typeof t);else{if("object"!=typeof t||"browser"!=f[i])continue;if(s&&(t=t[o],null==t))return o}return"string"==typeof t?"./"+t.replace(/^\.?\//,""):t}}function o(e,r,t){let i,o=e.exports;if(o){if("string"==typeof o)o={".":o};else for(i in o){"."!==i[0]&&(o={".":o});break}return n(e.name,o,r||".",t)}}function f(e,r,t){if(e.imports)return n(e.name,e.imports,r,t)}function s(e,n,t){return"#"===(n=r(e.name,n||"."))[0]?f(e,n,t):o(e,n,t)}export{o as exports,f as imports,i as legacy,s as resolve};
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
