/**
<<<<<<< HEAD
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
=======
 * Copyright (c) Meta Platforms, Inc. and affiliates.
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
<<<<<<< HEAD
export declare type MockFunctionMetadataType = 'object' | 'array' | 'regexp' | 'function' | 'constant' | 'collection' | 'null' | 'undefined';
export declare type MockFunctionMetadata<T, Y extends Array<unknown>, Type = MockFunctionMetadataType> = {
    ref?: number;
    members?: Record<string, MockFunctionMetadata<T, Y>>;
    mockImpl?: (...args: Y) => T;
    name?: string;
    refID?: number;
    type?: Type;
    value?: T;
    length?: number;
};
export declare type MockableFunction = (...args: Array<any>) => any;
export declare type MethodKeysOf<T> = {
    [K in keyof T]: T[K] extends MockableFunction ? K : never;
}[keyof T];
export declare type PropertyKeysOf<T> = {
    [K in keyof T]: T[K] extends MockableFunction ? never : K;
}[keyof T];
export declare type ArgumentsOf<T> = T extends (...args: infer A) => any ? A : never;
export declare type ConstructorArgumentsOf<T> = T extends new (...args: infer A) => any ? A : never;
export declare type MaybeMockedConstructor<T> = T extends new (...args: Array<any>) => infer R ? MockInstance<R, ConstructorArgumentsOf<T>> : T;
export declare type MockedFunction<T extends MockableFunction> = MockWithArgs<T> & {
    [K in keyof T]: T[K];
};
export declare type MockedFunctionDeep<T extends MockableFunction> = MockWithArgs<T> & MockedObjectDeep<T>;
export declare type MockedObject<T> = MaybeMockedConstructor<T> & {
    [K in MethodKeysOf<T>]: T[K] extends MockableFunction ? MockedFunction<T[K]> : T[K];
} & {
    [K in PropertyKeysOf<T>]: T[K];
};
export declare type MockedObjectDeep<T> = MaybeMockedConstructor<T> & {
    [K in MethodKeysOf<T>]: T[K] extends MockableFunction ? MockedFunctionDeep<T[K]> : T[K];
} & {
    [K in PropertyKeysOf<T>]: MaybeMockedDeep<T[K]>;
};
export declare type MaybeMockedDeep<T> = T extends MockableFunction ? MockedFunctionDeep<T> : T extends object ? MockedObjectDeep<T> : T;
export declare type MaybeMocked<T> = T extends MockableFunction ? MockedFunction<T> : T extends object ? MockedObject<T> : T;
export declare type ArgsType<T> = T extends (...args: infer A) => any ? A : never;
export declare type Mocked<T> = {
    [P in keyof T]: T[P] extends (...args: Array<any>) => any ? MockInstance<ReturnType<T[P]>, ArgsType<T[P]>> : T[P] extends Constructable ? MockedClass<T[P]> : T[P];
} & T;
export declare type MockedClass<T extends Constructable> = MockInstance<InstanceType<T>, T extends new (...args: infer P) => any ? P : never> & {
    prototype: T extends {
        prototype: any;
    } ? Mocked<T['prototype']> : never;
} & T;
export interface Constructable {
    new (...args: Array<any>): any;
}
export interface MockWithArgs<T extends MockableFunction> extends MockInstance<ReturnType<T>, ArgumentsOf<T>> {
    new (...args: ConstructorArgumentsOf<T>): T;
    (...args: ArgumentsOf<T>): ReturnType<T>;
}
export interface Mock<T, Y extends Array<unknown> = Array<unknown>> extends Function, MockInstance<T, Y> {
    new (...args: Y): T;
    (...args: Y): T;
}
export interface SpyInstance<T, Y extends Array<unknown>> extends MockInstance<T, Y> {
}
export interface MockInstance<T, Y extends Array<unknown>> {
    _isMockFunction: true;
    _protoImpl: Function;
    getMockName(): string;
    getMockImplementation(): Function | undefined;
    mock: MockFunctionState<T, Y>;
    mockClear(): this;
    mockReset(): this;
    mockRestore(): void;
    mockImplementation(fn: (...args: Y) => T): this;
    mockImplementation(fn: () => Promise<T>): this;
    mockImplementationOnce(fn: (...args: Y) => T): this;
    mockImplementationOnce(fn: () => Promise<T>): this;
    mockName(name: string): this;
    mockReturnThis(): this;
    mockReturnValue(value: T): this;
    mockReturnValueOnce(value: T): this;
    mockResolvedValue(value: Unpromisify<T>): this;
    mockResolvedValueOnce(value: Unpromisify<T>): this;
    mockRejectedValue(value: unknown): this;
    mockRejectedValueOnce(value: unknown): this;
}
declare type Unpromisify<T> = T extends Promise<infer R> ? R : never;
/**
 * Possible types of a MockFunctionResult.
 * 'return': The call completed by returning normally.
 * 'throw': The call completed by throwing a value.
 * 'incomplete': The call has not completed yet. This is possible if you read
 *               the  mock function result from within the mock function itself
 *               (or a function called by the mock function).
 */
declare type MockFunctionResultType = 'return' | 'throw' | 'incomplete';
/**
 * Represents the result of a single call to a mock function.
 */
declare type MockFunctionResult = {
    /**
     * Indicates how the call completed.
     */
    type: MockFunctionResultType;
    /**
     * The value that was either thrown or returned by the function.
     * Undefined when type === 'incomplete'.
     */
    value: unknown;
};
declare type MockFunctionState<T, Y extends Array<unknown>> = {
    calls: Array<Y>;
    instances: Array<T>;
    invocationCallOrder: Array<number>;
    /**
     * Getter for retrieving the last call arguments
     */
    lastCall?: Y;
    /**
     * List of results of calls to the mock function.
     */
    results: Array<MockFunctionResult>;
};
declare type NonFunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends (...args: Array<any>) => any ? never : K;
}[keyof T] & string;
declare type FunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends (...args: Array<any>) => any ? K : never;
}[keyof T] & string;
export declare class ModuleMocker {
    private _environmentGlobal;
    private _mockState;
    private _mockConfigRegistry;
    private _spyState;
    private _invocationCallCounter;
    /**
     * @see README.md
     * @param global Global object of the test environment, used to create
     * mocks
     */
    constructor(global: typeof globalThis);
    private _getSlots;
    private _ensureMockConfig;
    private _ensureMockState;
    private _defaultMockConfig;
    private _defaultMockState;
    private _makeComponent;
    private _createMockFunction;
    private _generateMock;
    /**
     * @see README.md
     * @param _metadata Metadata for the mock in the schema returned by the
     * getMetadata method of this module.
     */
    generateFromMetadata<T, Y extends Array<unknown>>(_metadata: MockFunctionMetadata<T, Y>): Mock<T, Y>;
    /**
     * @see README.md
     * @param component The component for which to retrieve metadata.
     */
    getMetadata<T, Y extends Array<unknown>>(component: T, _refs?: Map<T, number>): MockFunctionMetadata<T, Y> | null;
    isMockFunction<T>(fn: unknown): fn is Mock<T>;
    fn<T, Y extends Array<unknown>>(implementation?: (...args: Y) => T): Mock<T, Y>;
    spyOn<T extends {}, M extends NonFunctionPropertyNames<T>>(object: T, methodName: M, accessType: 'get'): SpyInstance<T[M], []>;
    spyOn<T extends {}, M extends NonFunctionPropertyNames<T>>(object: T, methodName: M, accessType: 'set'): SpyInstance<void, [T[M]]>;
    spyOn<T extends {}, M extends FunctionPropertyNames<T>>(object: T, methodName: M): T[M] extends (...args: Array<any>) => any ? SpyInstance<ReturnType<T[M]>, Parameters<T[M]>> : never;
    private _spyOnProperty;
    clearAllMocks(): void;
    resetAllMocks(): void;
    restoreAllMocks(): void;
    private _typeOf;
    mocked<T>(item: T, deep?: false): MaybeMocked<T>;
    mocked<T>(item: T, deep: true): MaybeMockedDeep<T>;
}
export declare const fn: <T, Y extends unknown[]>(implementation?: ((...args: Y) => T) | undefined) => Mock<T, Y>;
export declare const spyOn: {
    <T extends {}, M extends NonFunctionPropertyNames<T>>(object: T, methodName: M, accessType: 'get'): SpyInstance<T[M], []>;
    <T_2 extends {}, M_2 extends NonFunctionPropertyNames<T_2>>(object: T_2, methodName: M_2, accessType: 'set'): SpyInstance<void, [T_2[M_2]]>;
    <T_4 extends {}, M_4 extends FunctionPropertyNames<T_4>>(object: T_4, methodName: M_4): T_4[M_4] extends (...args: Array<any>) => any ? SpyInstance<ReturnType<T_4[M_4]>, Parameters<T_4[M_4]>> : never;
};
export declare const mocked: {
    <T>(item: T, deep?: false | undefined): MaybeMocked<T>;
    <T_2>(item: T_2, deep: true): MaybeMockedDeep<T_2>;
};
=======
export declare type ClassLike = {
  new (...args: any): any;
};

export declare type ConstructorLikeKeys<T> = keyof {
  [K in keyof T as Required<T>[K] extends ClassLike ? K : never]: T[K];
};

export declare const fn: <T extends FunctionLike = UnknownFunction>(
  implementation?: T | undefined,
) => Mock<T>;

export declare type FunctionLike = (...args: any) => any;

export declare type MethodLikeKeys<T> = keyof {
  [K in keyof T as Required<T>[K] extends FunctionLike ? K : never]: T[K];
};

/**
 * All what the internal typings need is to be sure that we have any-function.
 * `FunctionLike` type ensures that and helps to constrain the type as well.
 * The default of `UnknownFunction` makes sure that `any`s do not leak to the
 * user side. For instance, calling `fn()` without implementation will return
 * a mock of `(...args: Array<unknown>) => unknown` type. If implementation
 * is provided, its typings are inferred correctly.
 */
export declare interface Mock<T extends FunctionLike = UnknownFunction>
  extends Function,
    MockInstance<T> {
  new (...args: Parameters<T>): ReturnType<T>;
  (...args: Parameters<T>): ReturnType<T>;
}

export declare type Mocked<T> = T extends ClassLike
  ? MockedClass<T>
  : T extends FunctionLike
  ? MockedFunction<T>
  : T extends object
  ? MockedObject<T>
  : T;

export declare const mocked: {
  <T extends object>(
    source: T,
    options?: {
      shallow: false;
    },
  ): Mocked<T>;
  <T_1 extends object>(
    source: T_1,
    options: {
      shallow: true;
    },
  ): MockedShallow<T_1>;
};

export declare type MockedClass<T extends ClassLike> = MockInstance<
  (...args: ConstructorParameters<T>) => Mocked<InstanceType<T>>
> &
  MockedObject<T>;

export declare type MockedFunction<T extends FunctionLike> = MockInstance<T> &
  MockedObject<T>;

declare type MockedFunctionShallow<T extends FunctionLike> = MockInstance<T> &
  T;

export declare type MockedObject<T extends object> = {
  [K in keyof T]: T[K] extends ClassLike
    ? MockedClass<T[K]>
    : T[K] extends FunctionLike
    ? MockedFunction<T[K]>
    : T[K] extends object
    ? MockedObject<T[K]>
    : T[K];
} & T;

declare type MockedObjectShallow<T extends object> = {
  [K in keyof T]: T[K] extends ClassLike
    ? MockedClass<T[K]>
    : T[K] extends FunctionLike
    ? MockedFunctionShallow<T[K]>
    : T[K];
} & T;

export declare type MockedShallow<T> = T extends ClassLike
  ? MockedClass<T>
  : T extends FunctionLike
  ? MockedFunctionShallow<T>
  : T extends object
  ? MockedObjectShallow<T>
  : T;

export declare type MockFunctionMetadata<
  T = unknown,
  MetadataType = MockMetadataType,
> = MockMetadata<T, MetadataType>;

export declare type MockFunctionMetadataType = MockMetadataType;

declare type MockFunctionResult<T extends FunctionLike = UnknownFunction> =
  | MockFunctionResultIncomplete
  | MockFunctionResultReturn<T>
  | MockFunctionResultThrow;

declare type MockFunctionResultIncomplete = {
  type: 'incomplete';
  /**
   * Result of a single call to a mock function that has not yet completed.
   * This occurs if you test the result from within the mock function itself,
   * or from within a function that was called by the mock.
   */
  value: undefined;
};

declare type MockFunctionResultReturn<
  T extends FunctionLike = UnknownFunction,
> = {
  type: 'return';
  /**
   * Result of a single call to a mock function that returned.
   */
  value: ReturnType<T>;
};

declare type MockFunctionResultThrow = {
  type: 'throw';
  /**
   * Result of a single call to a mock function that threw.
   */
  value: unknown;
};

declare type MockFunctionState<T extends FunctionLike = UnknownFunction> = {
  /**
   * List of the call arguments of all calls that have been made to the mock.
   */
  calls: Array<Parameters<T>>;
  /**
   * List of all the object instances that have been instantiated from the mock.
   */
  instances: Array<ReturnType<T>>;
  /**
   * List of all the function contexts that have been applied to calls to the mock.
   */
  contexts: Array<ThisParameterType<T>>;
  /**
   * List of the call order indexes of the mock. Jest is indexing the order of
   * invocations of all mocks in a test file. The index is starting with `1`.
   */
  invocationCallOrder: Array<number>;
  /**
   * List of the call arguments of the last call that was made to the mock.
   * If the function was not called, it will return `undefined`.
   */
  lastCall?: Parameters<T>;
  /**
   * List of the results of all calls that have been made to the mock.
   */
  results: Array<MockFunctionResult<T>>;
};

export declare interface MockInstance<
  T extends FunctionLike = UnknownFunction,
> {
  _isMockFunction: true;
  _protoImpl: Function;
  getMockImplementation(): T | undefined;
  getMockName(): string;
  mock: MockFunctionState<T>;
  mockClear(): this;
  mockReset(): this;
  mockRestore(): void;
  mockImplementation(fn: T): this;
  mockImplementationOnce(fn: T): this;
  withImplementation(fn: T, callback: () => Promise<unknown>): Promise<void>;
  withImplementation(fn: T, callback: () => void): void;
  mockName(name: string): this;
  mockReturnThis(): this;
  mockReturnValue(value: ReturnType<T>): this;
  mockReturnValueOnce(value: ReturnType<T>): this;
  mockResolvedValue(value: ResolveType<T>): this;
  mockResolvedValueOnce(value: ResolveType<T>): this;
  mockRejectedValue(value: RejectType<T>): this;
  mockRejectedValueOnce(value: RejectType<T>): this;
}

export declare type MockMetadata<T, MetadataType = MockMetadataType> = {
  ref?: number;
  members?: Record<string, MockMetadata<T>>;
  mockImpl?: T;
  name?: string;
  refID?: number;
  type?: MetadataType;
  value?: T;
  length?: number;
};

export declare type MockMetadataType =
  | 'object'
  | 'array'
  | 'regexp'
  | 'function'
  | 'constant'
  | 'collection'
  | 'null'
  | 'undefined';

export declare class ModuleMocker {
  private readonly _environmentGlobal;
  private _mockState;
  private _mockConfigRegistry;
  private _spyState;
  private _invocationCallCounter;
  /**
   * @see README.md
   * @param global Global object of the test environment, used to create
   * mocks
   */
  constructor(global: typeof globalThis);
  private _getSlots;
  private _ensureMockConfig;
  private _ensureMockState;
  private _defaultMockConfig;
  private _defaultMockState;
  private _makeComponent;
  private _createMockFunction;
  private _generateMock;
  /**
   * Check whether the given property of an object has been already replaced.
   */
  private _findReplacedProperty;
  /**
   * @see README.md
   * @param metadata Metadata for the mock in the schema returned by the
   * getMetadata method of this module.
   */
  generateFromMetadata<T>(metadata: MockMetadata<T>): Mocked<T>;
  /**
   * @see README.md
   * @param component The component for which to retrieve metadata.
   */
  getMetadata<T = unknown>(
    component: T,
    _refs?: Map<T, number>,
  ): MockMetadata<T> | null;
  isMockFunction<T extends FunctionLike = UnknownFunction>(
    fn: MockInstance<T>,
  ): fn is MockInstance<T>;
  isMockFunction<P extends Array<unknown>, R>(
    fn: (...args: P) => R,
  ): fn is Mock<(...args: P) => R>;
  isMockFunction(fn: unknown): fn is Mock<UnknownFunction>;
  fn<T extends FunctionLike = UnknownFunction>(implementation?: T): Mock<T>;
  spyOn<
    T extends object,
    K extends PropertyLikeKeys<T>,
    V extends Required<T>[K],
    A extends 'get' | 'set',
  >(
    object: T,
    methodKey: K,
    accessType: A,
  ): A extends 'get'
    ? SpiedGetter<V>
    : A extends 'set'
    ? SpiedSetter<V>
    : never;
  spyOn<
    T extends object,
    K extends ConstructorLikeKeys<T> | MethodLikeKeys<T>,
    V extends Required<T>[K],
  >(
    object: T,
    methodKey: K,
  ): V extends ClassLike | FunctionLike ? Spied<V> : never;
  private _spyOnProperty;
  replaceProperty<T extends object, K extends keyof T>(
    object: T,
    propertyKey: K,
    value: T[K],
  ): Replaced<T[K]>;
  clearAllMocks(): void;
  resetAllMocks(): void;
  restoreAllMocks(): void;
  private _typeOf;
  mocked<T extends object>(
    source: T,
    options?: {
      shallow: false;
    },
  ): Mocked<T>;
  mocked<T extends object>(
    source: T,
    options: {
      shallow: true;
    },
  ): MockedShallow<T>;
}

export declare type PropertyLikeKeys<T> = Exclude<
  keyof T,
  ConstructorLikeKeys<T> | MethodLikeKeys<T>
>;

declare type RejectType<T extends FunctionLike> =
  ReturnType<T> extends PromiseLike<any> ? unknown : never;

export declare interface Replaced<T = unknown> {
  /**
   * Restore property to its original value known at the time of mocking.
   */
  restore(): void;
  /**
   * Change the value of the property.
   */
  replaceValue(value: T): this;
}

export declare const replaceProperty: <T extends object, K extends keyof T>(
  object: T,
  propertyKey: K,
  value: T[K],
) => Replaced<T[K]>;

declare type ResolveType<T extends FunctionLike> =
  ReturnType<T> extends PromiseLike<infer U> ? U : never;

export declare type Spied<T extends ClassLike | FunctionLike> =
  T extends ClassLike
    ? SpiedClass<T>
    : T extends FunctionLike
    ? SpiedFunction<T>
    : never;

export declare type SpiedClass<T extends ClassLike = UnknownClass> =
  MockInstance<(...args: ConstructorParameters<T>) => InstanceType<T>>;

export declare type SpiedFunction<T extends FunctionLike = UnknownFunction> =
  MockInstance<(...args: Parameters<T>) => ReturnType<T>>;

export declare type SpiedGetter<T> = MockInstance<() => T>;

export declare type SpiedSetter<T> = MockInstance<(arg: T) => void>;

export declare interface SpyInstance<T extends FunctionLike = UnknownFunction>
  extends MockInstance<T> {}

export declare const spyOn: {
  <
    T extends object,
    K_2 extends Exclude<
      keyof T,
      | keyof {
          [K in keyof T as Required<T>[K] extends ClassLike ? K : never]: T[K];
        }
      | keyof {
          [K_1 in keyof T as Required<T>[K_1] extends FunctionLike
            ? K_1
            : never]: T[K_1];
        }
    >,
    V extends Required<T>[K_2],
    A extends 'set' | 'get',
  >(
    object: T,
    methodKey: K_2,
    accessType: A,
  ): A extends 'get'
    ? SpiedGetter<V>
    : A extends 'set'
    ? SpiedSetter<V>
    : never;
  <
    T_1 extends object,
    K_5 extends
      | keyof {
          [K_3 in keyof T_1 as Required<T_1>[K_3] extends ClassLike
            ? K_3
            : never]: T_1[K_3];
        }
      | keyof {
          [K_4 in keyof T_1 as Required<T_1>[K_4] extends FunctionLike
            ? K_4
            : never]: T_1[K_4];
        },
    V_1 extends Required<T_1>[K_5],
  >(
    object: T_1,
    methodKey: K_5,
  ): V_1 extends ClassLike | FunctionLike ? Spied<V_1> : never;
};

export declare type UnknownClass = {
  new (...args: Array<unknown>): unknown;
};

export declare type UnknownFunction = (...args: Array<unknown>) => unknown;

>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
export {};
