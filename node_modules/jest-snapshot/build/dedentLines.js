'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.dedentLines = void 0;
<<<<<<< HEAD

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
=======
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
<<<<<<< HEAD
=======

>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const getIndentationLength = line => {
  const result = /^( {2})+/.exec(line);
  return result === null ? 0 : result[0].length;
};
<<<<<<< HEAD

const dedentLine = line => line.slice(getIndentationLength(line)); // Return true if:
// "key": "value has multiple lines\n…
// "key has multiple lines\n…

const hasUnmatchedDoubleQuoteMarks = string => {
  let n = 0;
  let i = string.indexOf('"', 0);

=======
const dedentLine = line => line.slice(getIndentationLength(line));

// Return true if:
// "key": "value has multiple lines\n…
// "key has multiple lines\n…
const hasUnmatchedDoubleQuoteMarks = string => {
  let n = 0;
  let i = string.indexOf('"', 0);
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  while (i !== -1) {
    if (i === 0 || string[i - 1] !== '\\') {
      n += 1;
    }
<<<<<<< HEAD

    i = string.indexOf('"', i + 1);
  }

  return n % 2 !== 0;
};

const isFirstLineOfTag = line => /^( {2})*\</.test(line); // The length of the output array is the index of the next input line.
=======
    i = string.indexOf('"', i + 1);
  }
  return n % 2 !== 0;
};
const isFirstLineOfTag = line => /^( {2})*</.test(line);

// The length of the output array is the index of the next input line.

>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
// Push dedented lines of start tag onto output and return true;
// otherwise return false because:
// * props include a multiline string (or text node, if props have markup)
// * start tag does not close
<<<<<<< HEAD

const dedentStartTag = (input, output) => {
  let line = input[output.length];
  output.push(dedentLine(line));

  if (line.includes('>')) {
    return true;
  }

  while (output.length < input.length) {
    line = input[output.length];

=======
const dedentStartTag = (input, output) => {
  let line = input[output.length];
  output.push(dedentLine(line));
  if (line.includes('>')) {
    return true;
  }
  while (output.length < input.length) {
    line = input[output.length];
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (hasUnmatchedDoubleQuoteMarks(line)) {
      return false; // because props include a multiline string
    } else if (isFirstLineOfTag(line)) {
      // Recursion only if props have markup.
      if (!dedentMarkup(input, output)) {
        return false;
      }
    } else {
      output.push(dedentLine(line));
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      if (line.includes('>')) {
        return true;
      }
    }
  }
<<<<<<< HEAD

  return false;
}; // Push dedented lines of markup onto output and return true;
=======
  return false;
};

// Push dedented lines of markup onto output and return true;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
// otherwise return false because:
// * props include a multiline string
// * text has more than one adjacent line
// * markup does not close
<<<<<<< HEAD

const dedentMarkup = (input, output) => {
  let line = input[output.length];

  if (!dedentStartTag(input, output)) {
    return false;
  }

  if (input[output.length - 1].includes('/>')) {
    return true;
  }

  let isText = false;
  const stack = [];
  stack.push(getIndentationLength(line));

  while (stack.length > 0 && output.length < input.length) {
    line = input[output.length];

=======
const dedentMarkup = (input, output) => {
  let line = input[output.length];
  if (!dedentStartTag(input, output)) {
    return false;
  }
  if (input[output.length - 1].includes('/>')) {
    return true;
  }
  let isText = false;
  const stack = [];
  stack.push(getIndentationLength(line));
  while (stack.length > 0 && output.length < input.length) {
    line = input[output.length];
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (isFirstLineOfTag(line)) {
      if (line.includes('</')) {
        output.push(dedentLine(line));
        stack.pop();
      } else {
        if (!dedentStartTag(input, output)) {
          return false;
        }
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
        if (!input[output.length - 1].includes('/>')) {
          stack.push(getIndentationLength(line));
        }
      }
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      isText = false;
    } else {
      if (isText) {
        return false; // because text has more than one adjacent line
      }

      const indentationLengthOfTag = stack[stack.length - 1];
      output.push(line.slice(indentationLengthOfTag + 2));
      isText = true;
    }
  }
<<<<<<< HEAD

  return stack.length === 0;
}; // Return lines unindented by heuristic;
=======
  return stack.length === 0;
};

// Return lines unindented by heuristic;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
// otherwise return null because:
// * props include a multiline string
// * text has more than one adjacent line
// * markup does not close
<<<<<<< HEAD

const dedentLines = input => {
  const output = [];

  while (output.length < input.length) {
    const line = input[output.length];

=======
const dedentLines = input => {
  const output = [];
  while (output.length < input.length) {
    const line = input[output.length];
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (hasUnmatchedDoubleQuoteMarks(line)) {
      return null;
    } else if (isFirstLineOfTag(line)) {
      if (!dedentMarkup(input, output)) {
        return null;
      }
    } else {
      output.push(dedentLine(line));
    }
  }
<<<<<<< HEAD

  return output;
};

=======
  return output;
};
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
exports.dedentLines = dedentLines;
