'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< HEAD
exports.getTestID =
  exports.getTestDuration =
  exports.getEachHooksForTest =
  exports.getAllHooksForDescribe =
  exports.describeBlockHasTests =
  exports.callAsyncCircusFn =
  exports.addErrorToEachTestUnderDescribe =
    void 0;
exports.invariant = invariant;
=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
exports.parseSingleTestResult =
  exports.makeTest =
  exports.makeSingleTestResult =
  exports.makeRunResult =
  exports.makeDescribe =
<<<<<<< HEAD
    void 0;

var path = _interopRequireWildcard(require('path'));

var _co = _interopRequireDefault(require('co'));

var _dedent = _interopRequireDefault(require('dedent'));

var _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));

var _slash = _interopRequireDefault(require('slash'));

var _stackUtils = _interopRequireDefault(require('stack-utils'));

var _jestUtil = require('jest-util');

var _prettyFormat = require('pretty-format');

var _state = require('./state');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

=======
  exports.getTestID =
  exports.getTestDuration =
  exports.getEachHooksForTest =
  exports.getAllHooksForDescribe =
  exports.describeBlockHasTests =
  exports.createTestCaseStartInfo =
  exports.callAsyncCircusFn =
  exports.addErrorToEachTestUnderDescribe =
    void 0;
var path = _interopRequireWildcard(require('path'));
var _co = _interopRequireDefault(require('co'));
var _dedent = _interopRequireDefault(require('dedent'));
var _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));
var _slash = _interopRequireDefault(require('slash'));
var _stackUtils = _interopRequireDefault(require('stack-utils'));
var _jestUtil = require('jest-util');
var _prettyFormat = require('pretty-format');
var _state = require('./state');
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
<<<<<<< HEAD

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var jestNow = global[Symbol.for('jest-native-now')] || global.Date.now;

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var global = (function () {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  } else if (typeof global !== 'undefined') {
    return global;
  } else if (typeof self !== 'undefined') {
    return self;
  } else if (typeof window !== 'undefined') {
    return window;
  } else {
    return Function('return this')();
  }
})();

var Promise = global[Symbol.for('jest-native-promise')] || global.Promise;
=======
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
var jestNow = globalThis[Symbol.for('jest-native-now')] || globalThis.Date.now;
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
var Promise =
  globalThis[Symbol.for('jest-native-promise')] || globalThis.Promise;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const stackUtils = new _stackUtils.default({
  cwd: 'A path that does not exist'
});
const jestEachBuildDir = (0, _slash.default)(
  path.dirname(require.resolve('jest-each'))
);
<<<<<<< HEAD

function takesDoneCallback(fn) {
  return fn.length > 0;
}

function isGeneratorFunction(fn) {
  return (0, _isGeneratorFn.default)(fn);
}

const makeDescribe = (name, parent, mode) => {
  let _mode = mode;

=======
function takesDoneCallback(fn) {
  return fn.length > 0;
}
function isGeneratorFunction(fn) {
  return (0, _isGeneratorFn.default)(fn);
}
const makeDescribe = (name, parent, mode) => {
  let _mode = mode;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (parent && !mode) {
    // If not set explicitly, inherit from the parent describe.
    _mode = parent.mode;
  }
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  return {
    type: 'describeBlock',
    // eslint-disable-next-line sort-keys
    children: [],
    hooks: [],
    mode: _mode,
    name: (0, _jestUtil.convertDescriptorToString)(name),
    parent,
    tests: []
  };
};
<<<<<<< HEAD

exports.makeDescribe = makeDescribe;

const makeTest = (fn, mode, name, parent, timeout, asyncError) => ({
  type: 'test',
  // eslint-disable-next-line sort-keys
  asyncError,
  duration: null,
  errors: [],
=======
exports.makeDescribe = makeDescribe;
const makeTest = (
  fn,
  mode,
  concurrent,
  name,
  parent,
  timeout,
  asyncError,
  failing
) => ({
  type: 'test',
  // eslint-disable-next-line sort-keys
  asyncError,
  concurrent,
  duration: null,
  errors: [],
  failing,
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  fn,
  invocations: 0,
  mode,
  name: (0, _jestUtil.convertDescriptorToString)(name),
<<<<<<< HEAD
  parent,
=======
  numPassingAsserts: 0,
  parent,
  retryReasons: [],
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  seenDone: false,
  startedAt: null,
  status: null,
  timeout
<<<<<<< HEAD
}); // Traverse the tree of describe blocks and return true if at least one describe
// block has an enabled test.

exports.makeTest = makeTest;

=======
});

// Traverse the tree of describe blocks and return true if at least one describe
// block has an enabled test.
exports.makeTest = makeTest;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const hasEnabledTest = describeBlock => {
  const {hasFocusedTests, testNamePattern} = (0, _state.getState)();
  return describeBlock.children.some(child =>
    child.type === 'describeBlock'
      ? hasEnabledTest(child)
      : !(
          child.mode === 'skip' ||
          (hasFocusedTests && child.mode !== 'only') ||
          (testNamePattern && !testNamePattern.test(getTestID(child)))
        )
  );
};
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const getAllHooksForDescribe = describe => {
  const result = {
    afterAll: [],
    beforeAll: []
  };
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (hasEnabledTest(describe)) {
    for (const hook of describe.hooks) {
      switch (hook.type) {
        case 'beforeAll':
          result.beforeAll.push(hook);
          break;
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
        case 'afterAll':
          result.afterAll.push(hook);
          break;
      }
    }
  }
<<<<<<< HEAD

  return result;
};

exports.getAllHooksForDescribe = getAllHooksForDescribe;

=======
  return result;
};
exports.getAllHooksForDescribe = getAllHooksForDescribe;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const getEachHooksForTest = test => {
  const result = {
    afterEach: [],
    beforeEach: []
  };
<<<<<<< HEAD
  let block = test.parent;

  do {
    const beforeEachForCurrentBlock = []; // TODO: inline after https://github.com/microsoft/TypeScript/pull/34840 is released

    let hook;

    for (hook of block.hooks) {
=======
  if (test.concurrent) {
    // *Each hooks are not run for concurrent tests
    return result;
  }
  let block = test.parent;
  do {
    const beforeEachForCurrentBlock = [];
    for (const hook of block.hooks) {
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      switch (hook.type) {
        case 'beforeEach':
          beforeEachForCurrentBlock.push(hook);
          break;
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
        case 'afterEach':
          result.afterEach.push(hook);
          break;
      }
<<<<<<< HEAD
    } // 'beforeEach' hooks are executed from top to bottom, the opposite of the
    // way we traversed it.

    result.beforeEach = [...beforeEachForCurrentBlock, ...result.beforeEach];
  } while ((block = block.parent));

  return result;
};

exports.getEachHooksForTest = getEachHooksForTest;

=======
    }
    // 'beforeEach' hooks are executed from top to bottom, the opposite of the
    // way we traversed it.
    result.beforeEach = [...beforeEachForCurrentBlock, ...result.beforeEach];
  } while ((block = block.parent));
  return result;
};
exports.getEachHooksForTest = getEachHooksForTest;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const describeBlockHasTests = describe =>
  describe.children.some(
    child => child.type === 'test' || describeBlockHasTests(child)
  );
<<<<<<< HEAD

exports.describeBlockHasTests = describeBlockHasTests;

const _makeTimeoutMessage = (timeout, isHook) =>
  `Exceeded timeout of ${(0, _jestUtil.formatTime)(timeout)} for a ${
    isHook ? 'hook' : 'test'
  }.\nUse jest.setTimeout(newTimeout) to increase the timeout value, if this is a long-running test.`; // Global values can be overwritten by mocks or tests. We'll capture
// the original values in the variables before we require any files.

const {setTimeout, clearTimeout} = global;

function checkIsError(error) {
  return !!(error && error.message && error.stack);
}

=======
exports.describeBlockHasTests = describeBlockHasTests;
const _makeTimeoutMessage = (timeout, isHook, takesDoneCallback) =>
  `Exceeded timeout of ${(0, _jestUtil.formatTime)(timeout)} for a ${
    isHook ? 'hook' : 'test'
  }${
    takesDoneCallback ? ' while waiting for `done()` to be called' : ''
  }.\nAdd a timeout value to this test to increase the timeout, if this is a long-running test. See https://jestjs.io/docs/api#testname-fn-timeout.`;

// Global values can be overwritten by mocks or tests. We'll capture
// the original values in the variables before we require any files.
const {setTimeout, clearTimeout} = globalThis;
function checkIsError(error) {
  return !!(error && error.message && error.stack);
}
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const callAsyncCircusFn = (testOrHook, testContext, {isHook, timeout}) => {
  let timeoutID;
  let completed = false;
  const {fn, asyncError} = testOrHook;
<<<<<<< HEAD
  return new Promise((resolve, reject) => {
    timeoutID = setTimeout(
      () => reject(_makeTimeoutMessage(timeout, isHook)),
      timeout
    ); // If this fn accepts `done` callback we return a promise that fulfills as
    // soon as `done` called.

    if (takesDoneCallback(fn)) {
      let returnedValue = undefined;

      const done = reason => {
        // We need to keep a stack here before the promise tick
        const errorAtDone = new _jestUtil.ErrorWithStack(undefined, done);

        if (!completed && testOrHook.seenDone) {
          errorAtDone.message =
            'Expected done to be called once, but it was called multiple times.';

          if (reason) {
            errorAtDone.message +=
              ' Reason: ' +
              (0, _prettyFormat.format)(reason, {
                maxDepth: 3
              });
          }

=======
  const doneCallback = takesDoneCallback(fn);
  return new Promise((resolve, reject) => {
    timeoutID = setTimeout(
      () => reject(_makeTimeoutMessage(timeout, isHook, doneCallback)),
      timeout
    );

    // If this fn accepts `done` callback we return a promise that fulfills as
    // soon as `done` called.
    if (doneCallback) {
      let returnedValue = undefined;
      const done = reason => {
        // We need to keep a stack here before the promise tick
        const errorAtDone = new _jestUtil.ErrorWithStack(undefined, done);
        if (!completed && testOrHook.seenDone) {
          errorAtDone.message =
            'Expected done to be called once, but it was called multiple times.';
          if (reason) {
            errorAtDone.message += ` Reason: ${(0, _prettyFormat.format)(
              reason,
              {
                maxDepth: 3
              }
            )}`;
          }
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
          reject(errorAtDone);
          throw errorAtDone;
        } else {
          testOrHook.seenDone = true;
<<<<<<< HEAD
        } // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously

=======
        }

        // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
        Promise.resolve().then(() => {
          if (returnedValue !== undefined) {
            asyncError.message = (0, _dedent.default)`
      Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.
      Returned value: ${(0, _prettyFormat.format)(returnedValue, {
        maxDepth: 3
      })}
      `;
            return reject(asyncError);
          }
<<<<<<< HEAD

          let errorAsErrorObject;

=======
          let errorAsErrorObject;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
          if (checkIsError(reason)) {
            errorAsErrorObject = reason;
          } else {
            errorAsErrorObject = errorAtDone;
            errorAtDone.message = `Failed: ${(0, _prettyFormat.format)(reason, {
              maxDepth: 3
            })}`;
<<<<<<< HEAD
          } // Consider always throwing, regardless if `reason` is set or not

          if (completed && reason) {
            errorAsErrorObject.message =
              'Caught error after test environment was torn down\n\n' +
              errorAsErrorObject.message;
            throw errorAsErrorObject;
          }

          return reason ? reject(errorAsErrorObject) : resolve();
        });
      };

      returnedValue = fn.call(testContext, done);
      return;
    }

    let returnedValue;

=======
          }

          // Consider always throwing, regardless if `reason` is set or not
          if (completed && reason) {
            errorAsErrorObject.message = `Caught error after test environment was torn down\n\n${errorAsErrorObject.message}`;
            throw errorAsErrorObject;
          }
          return reason ? reject(errorAsErrorObject) : resolve();
        });
      };
      returnedValue = fn.call(testContext, done);
      return;
    }
    let returnedValue;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (isGeneratorFunction(fn)) {
      returnedValue = _co.default.wrap(fn).call({});
    } else {
      try {
        returnedValue = fn.call(testContext);
      } catch (error) {
        reject(error);
        return;
      }
<<<<<<< HEAD
    } // If it's a Promise, return it. Test for an object with a `then` function
    // to support custom Promise implementations.

    if (
      typeof returnedValue === 'object' &&
      returnedValue !== null &&
      typeof returnedValue.then === 'function'
    ) {
      returnedValue.then(() => resolve(), reject);
      return;
    }

=======
    }
    if ((0, _jestUtil.isPromise)(returnedValue)) {
      returnedValue.then(() => resolve(), reject);
      return;
    }
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (!isHook && returnedValue !== undefined) {
      reject(
        new Error((0, _dedent.default)`
      test functions can only return Promise or undefined.
      Returned value: ${(0, _prettyFormat.format)(returnedValue, {
        maxDepth: 3
      })}
      `)
      );
      return;
<<<<<<< HEAD
    } // Otherwise this test is synchronous, and if it didn't throw it means
    // it passed.

    resolve();
  })
    .then(() => {
      var _timeoutID$unref, _timeoutID;

      completed = true; // If timeout is not cleared/unrefed the node process won't exit until
      // it's resolved.

      (_timeoutID$unref = (_timeoutID = timeoutID).unref) === null ||
      _timeoutID$unref === void 0
        ? void 0
        : _timeoutID$unref.call(_timeoutID);
      clearTimeout(timeoutID);
    })
    .catch(error => {
      var _timeoutID$unref2, _timeoutID2;

      completed = true;
      (_timeoutID$unref2 = (_timeoutID2 = timeoutID).unref) === null ||
      _timeoutID$unref2 === void 0
        ? void 0
        : _timeoutID$unref2.call(_timeoutID2);
=======
    }

    // Otherwise this test is synchronous, and if it didn't throw it means
    // it passed.
    resolve();
  })
    .then(() => {
      completed = true;
      // If timeout is not cleared/unrefed the node process won't exit until
      // it's resolved.
      timeoutID.unref?.();
      clearTimeout(timeoutID);
    })
    .catch(error => {
      completed = true;
      timeoutID.unref?.();
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      clearTimeout(timeoutID);
      throw error;
    });
};
<<<<<<< HEAD

exports.callAsyncCircusFn = callAsyncCircusFn;

=======
exports.callAsyncCircusFn = callAsyncCircusFn;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const getTestDuration = test => {
  const {startedAt} = test;
  return typeof startedAt === 'number' ? jestNow() - startedAt : null;
};
<<<<<<< HEAD

exports.getTestDuration = getTestDuration;

=======
exports.getTestDuration = getTestDuration;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const makeRunResult = (describeBlock, unhandledErrors) => ({
  testResults: makeTestResults(describeBlock),
  unhandledErrors: unhandledErrors.map(_getError).map(getErrorStack)
});
<<<<<<< HEAD

exports.makeRunResult = makeRunResult;

const makeSingleTestResult = test => {
  const {includeTestLocationInResult} = (0, _state.getState)();
  const testPath = [];
  let parent = test;
  const {status} = test;
  invariant(status, 'Status should be present after tests are run.');

  do {
    testPath.unshift(parent.name);
  } while ((parent = parent.parent));

  let location = null;

  if (includeTestLocationInResult) {
    var _parsedLine, _parsedLine$file;

    const stackLines = test.asyncError.stack.split('\n');
    const stackLine = stackLines[1];
    let parsedLine = stackUtils.parseLine(stackLine);

    if (
      (_parsedLine = parsedLine) !== null &&
      _parsedLine !== void 0 &&
      (_parsedLine$file = _parsedLine.file) !== null &&
      _parsedLine$file !== void 0 &&
      _parsedLine$file.startsWith(jestEachBuildDir)
    ) {
      const stackLine = stackLines[4];
      parsedLine = stackUtils.parseLine(stackLine);
    }

=======
exports.makeRunResult = makeRunResult;
const getTestNamesPath = test => {
  const titles = [];
  let parent = test;
  do {
    titles.unshift(parent.name);
  } while ((parent = parent.parent));
  return titles;
};
const makeSingleTestResult = test => {
  const {includeTestLocationInResult} = (0, _state.getState)();
  const {status} = test;
  (0, _jestUtil.invariant)(
    status,
    'Status should be present after tests are run.'
  );
  const testPath = getTestNamesPath(test);
  let location = null;
  if (includeTestLocationInResult) {
    const stackLines = test.asyncError.stack.split('\n');
    const stackLine = stackLines[1];
    let parsedLine = stackUtils.parseLine(stackLine);
    if (parsedLine?.file?.startsWith(jestEachBuildDir)) {
      const stackLine = stackLines[4];
      parsedLine = stackUtils.parseLine(stackLine);
    }
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (
      parsedLine &&
      typeof parsedLine.column === 'number' &&
      typeof parsedLine.line === 'number'
    ) {
      location = {
        column: parsedLine.column,
        line: parsedLine.line
      };
    }
  }
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  const errorsDetailed = test.errors.map(_getError);
  return {
    duration: test.duration,
    errors: errorsDetailed.map(getErrorStack),
    errorsDetailed,
    invocations: test.invocations,
    location,
<<<<<<< HEAD
=======
    numPassingAsserts: test.numPassingAsserts,
    retryReasons: test.retryReasons.map(_getError).map(getErrorStack),
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    status,
    testPath: Array.from(testPath)
  };
};
<<<<<<< HEAD

exports.makeSingleTestResult = makeSingleTestResult;

const makeTestResults = describeBlock => {
  const testResults = [];

=======
exports.makeSingleTestResult = makeSingleTestResult;
const makeTestResults = describeBlock => {
  const testResults = [];
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  for (const child of describeBlock.children) {
    switch (child.type) {
      case 'describeBlock': {
        testResults.push(...makeTestResults(child));
        break;
      }
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      case 'test': {
        testResults.push(makeSingleTestResult(child));
        break;
      }
    }
  }
<<<<<<< HEAD

  return testResults;
}; // Return a string that identifies the test (concat of parent describe block
// names + test title)

const getTestID = test => {
  const titles = [];
  let parent = test;

  do {
    titles.unshift(parent.name);
  } while ((parent = parent.parent));

  titles.shift(); // remove TOP_DESCRIBE_BLOCK_NAME

  return titles.join(' ');
};

exports.getTestID = getTestID;

const _getError = errors => {
  let error;
  let asyncError;

=======
  return testResults;
};

// Return a string that identifies the test (concat of parent describe block
// names + test title)
const getTestID = test => {
  const testNamesPath = getTestNamesPath(test);
  testNamesPath.shift(); // remove TOP_DESCRIBE_BLOCK_NAME
  return testNamesPath.join(' ');
};
exports.getTestID = getTestID;
const _getError = errors => {
  let error;
  let asyncError;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (Array.isArray(errors)) {
    error = errors[0];
    asyncError = errors[1];
  } else {
    error = errors;
    asyncError = new Error();
  }
<<<<<<< HEAD

  if (error && (typeof error.stack === 'string' || error.message)) {
    return error;
  }

=======
  if (error && (typeof error.stack === 'string' || error.message)) {
    return error;
  }
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  asyncError.message = `thrown: ${(0, _prettyFormat.format)(error, {
    maxDepth: 3
  })}`;
  return asyncError;
};
<<<<<<< HEAD

const getErrorStack = error =>
  typeof error.stack === 'string' ? error.stack : error.message;

=======
const getErrorStack = error =>
  typeof error.stack === 'string' ? error.stack : error.message;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const addErrorToEachTestUnderDescribe = (describeBlock, error, asyncError) => {
  for (const child of describeBlock.children) {
    switch (child.type) {
      case 'describeBlock':
        addErrorToEachTestUnderDescribe(child, error, asyncError);
        break;
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      case 'test':
        child.errors.push([error, asyncError]);
        break;
    }
  }
};
<<<<<<< HEAD

exports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe;

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

const parseSingleTestResult = testResult => {
  let status;

=======
exports.addErrorToEachTestUnderDescribe = addErrorToEachTestUnderDescribe;
const resolveTestCaseStartInfo = testNamesPath => {
  const ancestorTitles = testNamesPath.filter(
    name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME
  );
  const fullName = ancestorTitles.join(' ');
  const title = testNamesPath[testNamesPath.length - 1];
  // remove title
  ancestorTitles.pop();
  return {
    ancestorTitles,
    fullName,
    title
  };
};
const parseSingleTestResult = testResult => {
  let status;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (testResult.status === 'skip') {
    status = 'pending';
  } else if (testResult.status === 'todo') {
    status = 'todo';
  } else if (testResult.errors.length > 0) {
    status = 'failed';
  } else {
    status = 'passed';
  }
<<<<<<< HEAD

  const ancestorTitles = testResult.testPath.filter(
    name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME
  );
  const title = ancestorTitles.pop();
=======
  const {ancestorTitles, fullName, title} = resolveTestCaseStartInfo(
    testResult.testPath
  );
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  return {
    ancestorTitles,
    duration: testResult.duration,
    failureDetails: testResult.errorsDetailed,
    failureMessages: Array.from(testResult.errors),
<<<<<<< HEAD
    fullName: title
      ? ancestorTitles.concat(title).join(' ')
      : ancestorTitles.join(' '),
    invocations: testResult.invocations,
    location: testResult.location,
    numPassingAsserts: 0,
    status,
    title: testResult.testPath[testResult.testPath.length - 1]
  };
};

exports.parseSingleTestResult = parseSingleTestResult;
=======
    fullName,
    invocations: testResult.invocations,
    location: testResult.location,
    numPassingAsserts: testResult.numPassingAsserts,
    retryReasons: Array.from(testResult.retryReasons),
    status,
    title
  };
};
exports.parseSingleTestResult = parseSingleTestResult;
const createTestCaseStartInfo = test => {
  const testPath = getTestNamesPath(test);
  const {ancestorTitles, fullName, title} = resolveTestCaseStartInfo(testPath);
  return {
    ancestorTitles,
    fullName,
    mode: test.mode,
    startedAt: test.startedAt,
    title
  };
};
exports.createTestCaseStartInfo = createTestCaseStartInfo;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
