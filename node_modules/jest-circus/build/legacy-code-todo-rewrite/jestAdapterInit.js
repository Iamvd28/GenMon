'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.runAndTransformResultsToJestFormat = exports.initialize = void 0;
<<<<<<< HEAD

var _throat = _interopRequireDefault(require('throat'));

var _testResult = require('@jest/test-result');

var _expect = require('expect');

var _jestEach = require('jest-each');

var _jestMessageUtil = require('jest-message-util');

var _jestSnapshot = require('jest-snapshot');

var _ = _interopRequireDefault(require('..'));

var _run = _interopRequireDefault(require('../run'));

var _state = require('../state');

var _testCaseReportHandler = _interopRequireDefault(
  require('../testCaseReportHandler')
);

var _utils = require('../utils');

var _jestExpect = _interopRequireDefault(require('./jestExpect'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
=======
var _expect = require('@jest/expect');
var _testResult = require('@jest/test-result');
var _jestMessageUtil = require('jest-message-util');
var _jestSnapshot = require('jest-snapshot');
var _ = _interopRequireDefault(require('..'));
var _run = _interopRequireDefault(require('../run'));
var _state = require('../state');
var _testCaseReportHandler = _interopRequireDefault(
  require('../testCaseReportHandler')
);
var _utils = require('../utils');
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
<<<<<<< HEAD
=======

>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const initialize = async ({
  config,
  environment,
  globalConfig,
  localRequire,
  parentProcess,
  sendMessageToJest,
  setGlobalsForRuntime,
  testPath
}) => {
  if (globalConfig.testTimeout) {
    (0, _state.getState)().testTimeout = globalConfig.testTimeout;
  }
<<<<<<< HEAD

  const mutex = (0, _throat.default)(globalConfig.maxConcurrency); // @ts-expect-error

=======
  (0, _state.getState)().maxConcurrency = globalConfig.maxConcurrency;
  (0, _state.getState)().randomize = globalConfig.randomize;
  (0, _state.getState)().seed = globalConfig.seed;

  // @ts-expect-error: missing `concurrent` which is added later
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  const globalsObject = {
    ..._.default,
    fdescribe: _.default.describe.only,
    fit: _.default.it.only,
    xdescribe: _.default.describe.skip,
    xit: _.default.it.skip,
    xtest: _.default.it.skip
  };
<<<<<<< HEAD

  globalsObject.test.concurrent = (test => {
    const concurrent = (testName, testFn, timeout) => {
      // For concurrent tests we first run the function that returns promise, and then register a
      // normal test that will be waiting on the returned promise (when we start the test, the promise
      // will already be in the process of execution).
      // Unfortunately at this stage there's no way to know if there are any `.only` tests in the suite
      // that will result in this test to be skipped, so we'll be executing the promise function anyway,
      // even if it ends up being skipped.
      const promise = mutex(() => testFn()); // Avoid triggering the uncaught promise rejection handler in case the test errors before
      // being awaited on.

      promise.catch(() => {});
      globalsObject.test(testName, () => promise, timeout);
    };

    const only = (testName, testFn, timeout) => {
      const promise = mutex(() => testFn()); // eslint-disable-next-line jest/no-focused-tests

      test.only(testName, () => promise, timeout);
    };

    concurrent.only = only;
    concurrent.skip = test.skip;
    concurrent.each = (0, _jestEach.bind)(test, false);
    concurrent.skip.each = (0, _jestEach.bind)(test.skip, false);
    only.each = (0, _jestEach.bind)(test.only, false);
    return concurrent;
  })(globalsObject.test);

  (0, _state.addEventHandler)(eventHandler);

  if (environment.handleTestEvent) {
    (0, _state.addEventHandler)(environment.handleTestEvent.bind(environment));
  }

  const runtimeGlobals = {
    ...globalsObject,
    expect: (0, _jestExpect.default)(globalConfig)
  };
  setGlobalsForRuntime(runtimeGlobals);

  if (config.injectGlobals) {
    Object.assign(environment.global, runtimeGlobals);
  }

=======
  (0, _state.addEventHandler)(eventHandler);
  if (environment.handleTestEvent) {
    (0, _state.addEventHandler)(environment.handleTestEvent.bind(environment));
  }
  _expect.jestExpect.setState({
    expand: globalConfig.expand
  });
  const runtimeGlobals = {
    ...globalsObject,
    expect: _expect.jestExpect
  };
  setGlobalsForRuntime(runtimeGlobals);
  if (config.injectGlobals) {
    Object.assign(environment.global, runtimeGlobals);
  }
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  await (0, _state.dispatch)({
    name: 'setup',
    parentProcess,
    runtimeGlobals,
    testNamePattern: globalConfig.testNamePattern
  });
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (config.testLocationInResults) {
    await (0, _state.dispatch)({
      name: 'include_test_location_in_result'
    });
<<<<<<< HEAD
  } // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.

=======
  }

  // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  config.snapshotSerializers
    .concat()
    .reverse()
    .forEach(path => (0, _jestSnapshot.addSerializer)(localRequire(path)));
<<<<<<< HEAD
  const {expand, updateSnapshot} = globalConfig;
=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  const snapshotResolver = await (0, _jestSnapshot.buildSnapshotResolver)(
    config,
    localRequire
  );
  const snapshotPath = snapshotResolver.resolveSnapshotPath(testPath);
  const snapshotState = new _jestSnapshot.SnapshotState(snapshotPath, {
<<<<<<< HEAD
    expand,
    prettierPath: config.prettierPath,
    snapshotFormat: config.snapshotFormat,
    updateSnapshot
  }); // @ts-expect-error: snapshotState is a jest extension of `expect`

  (0, _expect.setState)({
=======
    expand: globalConfig.expand,
    prettierPath: config.prettierPath,
    rootDir: config.rootDir,
    snapshotFormat: config.snapshotFormat,
    updateSnapshot: globalConfig.updateSnapshot
  });
  _expect.jestExpect.setState({
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    snapshotState,
    testPath
  });
  (0, _state.addEventHandler)(handleSnapshotStateAfterRetry(snapshotState));
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (sendMessageToJest) {
    (0, _state.addEventHandler)(
      (0, _testCaseReportHandler.default)(testPath, sendMessageToJest)
    );
<<<<<<< HEAD
  } // Return it back to the outer scope (test runner outside the VM).

=======
  }

  // Return it back to the outer scope (test runner outside the VM).
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  return {
    globals: globalsObject,
    snapshotState
  };
};
<<<<<<< HEAD

exports.initialize = initialize;

=======
exports.initialize = initialize;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const runAndTransformResultsToJestFormat = async ({
  config,
  globalConfig,
  testPath
}) => {
  const runResult = await (0, _run.default)();
  let numFailingTests = 0;
  let numPassingTests = 0;
  let numPendingTests = 0;
  let numTodoTests = 0;
  const assertionResults = runResult.testResults.map(testResult => {
    let status;
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    if (testResult.status === 'skip') {
      status = 'pending';
      numPendingTests += 1;
    } else if (testResult.status === 'todo') {
      status = 'todo';
      numTodoTests += 1;
    } else if (testResult.errors.length) {
      status = 'failed';
      numFailingTests += 1;
    } else {
      status = 'passed';
      numPassingTests += 1;
    }
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
    const ancestorTitles = testResult.testPath.filter(
      name => name !== _state.ROOT_DESCRIBE_BLOCK_NAME
    );
    const title = ancestorTitles.pop();
    return {
      ancestorTitles,
      duration: testResult.duration,
      failureDetails: testResult.errorsDetailed,
      failureMessages: testResult.errors,
      fullName: title
        ? ancestorTitles.concat(title).join(' ')
        : ancestorTitles.join(' '),
      invocations: testResult.invocations,
      location: testResult.location,
<<<<<<< HEAD
      numPassingAsserts: 0,
=======
      numPassingAsserts: testResult.numPassingAsserts,
      retryReasons: testResult.retryReasons,
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      status,
      title: testResult.testPath[testResult.testPath.length - 1]
    };
  });
  let failureMessage = (0, _jestMessageUtil.formatResultsErrors)(
    assertionResults,
    config,
    globalConfig,
    testPath
  );
  let testExecError;
<<<<<<< HEAD

=======
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (runResult.unhandledErrors.length) {
    testExecError = {
      message: '',
      stack: runResult.unhandledErrors.join('\n')
    };
<<<<<<< HEAD
    failureMessage =
      (failureMessage || '') +
      '\n\n' +
      runResult.unhandledErrors
        .map(err =>
          (0, _jestMessageUtil.formatExecError)(err, config, globalConfig)
        )
        .join('\n');
  }

=======
    failureMessage = `${failureMessage || ''}\n\n${runResult.unhandledErrors
      .map(err =>
        (0, _jestMessageUtil.formatExecError)(err, config, globalConfig)
      )
      .join('\n')}`;
  }
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  await (0, _state.dispatch)({
    name: 'teardown'
  });
  return {
    ...(0, _testResult.createEmptyTestResult)(),
    console: undefined,
    displayName: config.displayName,
    failureMessage,
    numFailingTests,
    numPassingTests,
    numPendingTests,
    numTodoTests,
    testExecError,
    testFilePath: testPath,
    testResults: assertionResults
  };
};
<<<<<<< HEAD

exports.runAndTransformResultsToJestFormat = runAndTransformResultsToJestFormat;

=======
exports.runAndTransformResultsToJestFormat = runAndTransformResultsToJestFormat;
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
const handleSnapshotStateAfterRetry = snapshotState => event => {
  switch (event.name) {
    case 'test_retry': {
      // Clear any snapshot data that occurred in previous test run
      snapshotState.clear();
    }
  }
};
<<<<<<< HEAD

const eventHandler = async event => {
  switch (event.name) {
    case 'test_start': {
      (0, _expect.setState)({
=======
const eventHandler = async event => {
  switch (event.name) {
    case 'test_start': {
      _expect.jestExpect.setState({
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
        currentTestName: (0, _utils.getTestID)(event.test)
      });
      break;
    }
<<<<<<< HEAD

    case 'test_done': {
      _addSuppressedErrors(event.test);

      _addExpectedAssertionErrors(event.test);

=======
    case 'test_done': {
      event.test.numPassingAsserts =
        _expect.jestExpect.getState().numPassingAsserts;
      _addSuppressedErrors(event.test);
      _addExpectedAssertionErrors(event.test);
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
      break;
    }
  }
};
<<<<<<< HEAD

const _addExpectedAssertionErrors = test => {
  const failures = (0, _expect.extractExpectedAssertionsErrors)();
  const errors = failures.map(failure => failure.error);
  test.errors = test.errors.concat(errors);
}; // Get suppressed errors from ``jest-matchers`` that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.

const _addSuppressedErrors = test => {
  const {suppressedErrors} = (0, _expect.getState)();
  (0, _expect.setState)({
    suppressedErrors: []
  });

=======
const _addExpectedAssertionErrors = test => {
  const failures = _expect.jestExpect.extractExpectedAssertionsErrors();
  const errors = failures.map(failure => failure.error);
  test.errors = test.errors.concat(errors);
};

// Get suppressed errors from ``jest-matchers`` that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.
const _addSuppressedErrors = test => {
  const {suppressedErrors} = _expect.jestExpect.getState();
  _expect.jestExpect.setState({
    suppressedErrors: []
  });
>>>>>>> 0df6b5ffd0a73ba47ae7921ccf86e80e012f120e
  if (suppressedErrors.length) {
    test.errors = test.errors.concat(suppressedErrors);
  }
};
